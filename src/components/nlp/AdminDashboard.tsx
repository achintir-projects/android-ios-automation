'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { 
  Settings, 
  Trash2, 
  Download, 
  Upload, 
  BarChart3, 
  Users, 
  Clock, 
  TrendingUp,
  Filter,
  Search,
  RefreshCw,
  AlertTriangle,
  CheckCircle
} from 'lucide-react';

interface AdminAppData {
  id: string;
  name: string;
  description: string;
  originalInput: string;
  domain: string;
  requirements: string;
  specifications: string;
  metadata: string;
  isTemplate: boolean;
  tags: string;
  createdAt: string;
  updatedAt: string;
  parsedMetadata?: any;
  parsedRequirements?: any;
  parsedSpecifications?: any;
  parsedTags?: string[];
}

interface AdminStats {
  totalApps: number;
  templateCount: number;
  autoGeneratedCount: number;
  domainDistribution: Record<string, number>;
  recentActivity: Array<{
    id: string;
    name: string;
    createdAt: string;
    domain: string;
    isTemplate: boolean;
  }>;
}

export default function AdminDashboard() {
  const [apps, setApps] = useState<AdminAppData[]>([]);
  const [stats, setStats] = useState<AdminStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [selectedApp, setSelectedApp] = useState<AdminAppData | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [bulkDeleteDialogOpen, setBulkDeleteDialogOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [filters, setFilters] = useState({
    domain: 'all',
    isTemplate: 'all',
    autoGenerated: 'all',
    sortBy: 'createdAt',
    sortOrder: 'desc'
  });

  useEffect(() => {
    loadAdminData();
  }, [filters]);

  const loadAdminData = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams({
        page: '1',
        limit: '100',
        sortBy: filters.sortBy,
        sortOrder: filters.sortOrder
      });

      if (filters.domain && filters.domain !== 'all') params.append('domain', filters.domain);
      if (filters.isTemplate && filters.isTemplate !== 'all') params.append('template', filters.isTemplate);
      if (filters.autoGenerated && filters.autoGenerated !== 'all') params.append('autoGenerated', filters.autoGenerated);

      const response = await fetch(`/api/saved-apps/admin?${params}`);
      const result = await response.json();
      
      if (result.success) {
        setApps(result.data);
        setStats(result.stats);
      }
    } catch (error) {
      console.error('Error loading admin data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteApp = async (appId: string) => {
    try {
      const response = await fetch(`/api/saved-apps/admin?appId=${appId}`, {
        method: 'DELETE',
      });
      
      const result = await response.json();
      
      if (result.success) {
        setApps(prev => prev.filter(app => app.id !== appId));
        setDeleteDialogOpen(false);
        setSelectedApp(null);
        loadAdminData(); // Refresh stats
      } else {
        alert(result.error || 'Failed to delete app');
      }
    } catch (error) {
      console.error('Error deleting app:', error);
      alert('Failed to delete app');
    }
  };

  const handleBulkDelete = async (criteria: string) => {
    try {
      const params = new URLSearchParams();
      
      if (criteria === 'old') {
        // Delete apps older than 30 days
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - 30);
        params.append('olderThan', cutoffDate.toISOString());
      } else if (criteria === 'autoGenerated') {
        // Delete all auto-generated apps
        const autoGeneratedApps = apps.filter(app => app.parsedMetadata?.autoGenerated);
        for (const app of autoGeneratedApps) {
          await fetch(`/api/saved-apps/admin?appId=${app.id}`, { method: 'DELETE' });
        }
      }
      
      const response = await fetch(`/api/saved-apps/admin?${params}`, {
        method: 'DELETE',
      });
      
      const result = await response.json();
      
      if (result.success) {
        setBulkDeleteDialogOpen(false);
        loadAdminData(); // Refresh data
      } else {
        alert(result.error || 'Failed to perform bulk delete');
      }
    } catch (error) {
      console.error('Error in bulk delete:', error);
      alert('Failed to perform bulk delete');
    }
  };

  const handleExportData = () => {
    const exportData = {
      exportedAt: new Date().toISOString(),
      stats,
      apps: apps.map(app => ({
        id: app.id,
        name: app.name,
        description: app.description,
        domain: app.domain,
        isTemplate: app.isTemplate,
        tags: app.parsedTags || [],
        createdAt: app.createdAt,
        updatedAt: app.updatedAt,
        metadata: app.parsedMetadata || {},
        hasRequirements: !!app.parsedRequirements,
        hasSpecifications: !!app.parsedSpecifications
      }))
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `apps_export_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const filteredApps = apps.filter(app => 
    app.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    app.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (app.parsedTags || []).some((tag: string) => 
      tag.toLowerCase().includes(searchTerm.toLowerCase())
    )
  );

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.8) return 'bg-green-100 text-green-800';
    if (confidence >= 0.6) return 'bg-yellow-100 text-yellow-800';
    return 'bg-red-100 text-red-800';
  };

  return (
    <div className="max-w-7xl mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold flex items-center gap-2">
            <Settings className="h-8 w-8" />
            Admin Dashboard
          </h1>
          <p className="text-muted-foreground">
            Manage all saved apps and templates in the platform
          </p>
        </div>
        
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            onClick={loadAdminData} 
            disabled={loading}
            className="gap-2"
          >
            {loading ? <RefreshCw className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
            Refresh
          </Button>
          
          <Button 
            variant="outline" 
            onClick={handleExportData}
            className="gap-2"
          >
            <Download className="h-4 w-4" />
            Export Data
          </Button>
          
          <Button 
            variant="destructive" 
            onClick={() => setBulkDeleteDialogOpen(true)}
            className="gap-2"
          >
            <Trash2 className="h-4 w-4" />
            Bulk Delete
          </Button>
        </div>
      </div>

      {/* Statistics Cards */}
      {stats && (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Total Apps</CardTitle>
              <BarChart3 className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{stats.totalApps}</div>
              <p className="text-xs text-muted-foreground">
                +{stats.recentActivity.length} recent
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Templates</CardTitle>
              <Users className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{stats.templateCount}</div>
              <p className="text-xs text-muted-foreground">
                {((stats.templateCount / stats.totalApps) * 100).toFixed(1)}% of total
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Auto-Generated</CardTitle>
              <TrendingUp className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{stats.autoGeneratedCount}</div>
              <p className="text-xs text-muted-foreground">
                {((stats.autoGeneratedCount / stats.totalApps) * 100).toFixed(1)}% of total
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Active Domains</CardTitle>
              <Clock className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{Object.keys(stats.domainDistribution).length}</div>
              <p className="text-xs text-muted-foreground">
                Most active: {Object.entries(stats.domainDistribution).sort(([,a], [,b]) => b - a)[0]?.[0] || 'N/A'}
              </p>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Filters and Search */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Filter className="h-5 w-5" />
            Filters & Search
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
            <div className="relative">
              <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search apps..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10"
              />
            </div>
            
            <Select value={filters.domain} onValueChange={(value) => setFilters(prev => ({ ...prev, domain: value }))}>
              <SelectTrigger>
                <SelectValue placeholder="All Domains" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Domains</SelectItem>
                {stats && Object.keys(stats.domainDistribution).map(domain => (
                  <SelectItem key={domain} value={domain}>{domain}</SelectItem>
                ))}
              </SelectContent>
            </Select>
            
            <Select value={filters.isTemplate} onValueChange={(value) => setFilters(prev => ({ ...prev, isTemplate: value }))}>
              <SelectTrigger>
                <SelectValue placeholder="All Types" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Types</SelectItem>
                <SelectItem value="true">Templates Only</SelectItem>
                <SelectItem value="false">Apps Only</SelectItem>
              </SelectContent>
            </Select>
            
            <Select value={filters.autoGenerated} onValueChange={(value) => setFilters(prev => ({ ...prev, autoGenerated: value }))}>
              <SelectTrigger>
                <SelectValue placeholder="All Sources" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Sources</SelectItem>
                <SelectItem value="true">Auto-Generated</SelectItem>
                <SelectItem value="false">Manual</SelectItem>
              </SelectContent>
            </Select>
            
            <Select value={`${filters.sortBy}-${filters.sortOrder}`} onValueChange={(value) => {
              const [sortBy, sortOrder] = value.split('-');
              setFilters(prev => ({ ...prev, sortBy, sortOrder }));
            }}>
              <SelectTrigger>
                <SelectValue placeholder="Sort By" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="createdAt-desc">Newest First</SelectItem>
                <SelectItem value="createdAt-asc">Oldest First</SelectItem>
                <SelectItem value="name-asc">Name A-Z</SelectItem>
                <SelectItem value="name-desc">Name Z-A</SelectItem>
                <SelectItem value="confidence-desc">Highest Confidence</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Apps List */}
      <Card>
        <CardHeader>
          <CardTitle>Applications ({filteredApps.length})</CardTitle>
          <CardDescription>
            All saved applications and templates in the platform
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4 max-h-96 overflow-y-auto">
            {filteredApps.map((app) => (
              <div key={app.id} className="flex items-center justify-between p-4 border rounded-lg hover:bg-muted/50">
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-1">
                    <h3 className="font-medium">{app.name}</h3>
                    {app.isTemplate && (
                      <Badge variant="secondary">Template</Badge>
                    )}
                    {app.parsedMetadata?.autoGenerated && (
                      <Badge variant="outline">Auto-Generated</Badge>
                    )}
                    {app.parsedMetadata?.recoveryAttempt && (
                      <Badge variant="outline" className="border-yellow-200 text-yellow-800">
                        <AlertTriangle className="h-3 w-3 mr-1" />
                        Recovered
                      </Badge>
                    )}
                  </div>
                  
                  <p className="text-sm text-muted-foreground mb-2">
                    {app.description || 'No description'}
                  </p>
                  
                  <div className="flex items-center gap-4 text-xs text-muted-foreground">
                    <span>Domain: {app.domain}</span>
                    <span>Created: {new Date(app.createdAt).toLocaleDateString()}</span>
                    {app.parsedMetadata?.confidence && (
                      <Badge className={getConfidenceColor(app.parsedMetadata.confidence)}>
                        {(app.parsedMetadata.confidence * 100).toFixed(0)}%
                      </Badge>
                    )}
                  </div>
                  
                  <div className="flex flex-wrap gap-1 mt-2">
                    {(app.parsedTags || []).slice(0, 3).map((tag, index) => (
                      <Badge key={index} variant="outline" className="text-xs">
                        {tag}
                      </Badge>
                    ))}
                    {(app.parsedTags || []).length > 3 && (
                      <Badge variant="outline" className="text-xs">
                        +{(app.parsedTags || []).length - 3} more
                      </Badge>
                    )}
                  </div>
                </div>
                
                <div className="flex items-center gap-2 ml-4">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(app.originalInput).catch(() => {
                          // Fallback for clipboard API not being available
                          const textArea = document.createElement('textarea');
                          textArea.value = app.originalInput;
                          document.body.appendChild(textArea);
                          textArea.select();
                          try {
                            document.execCommand('copy');
                          } catch (err) {
                            console.error('Failed to copy to clipboard:', err);
                          }
                          document.body.removeChild(textArea);
                        });
                      } else {
                        // Fallback for browsers that don't support clipboard API
                        const textArea = document.createElement('textarea');
                        textArea.value = app.originalInput;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                          document.execCommand('copy');
                        } catch (err) {
                          console.error('Failed to copy to clipboard:', err);
                        }
                        document.body.removeChild(textArea);
                      }
                      // You could add a toast here
                    }}
                  >
                    Copy Input
                  </Button>
                  
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setSelectedApp(app)}
                  >
                    View Details
                  </Button>
                  
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => {
                      setSelectedApp(app);
                      setDeleteDialogOpen(true);
                    }}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            ))}
            
            {filteredApps.length === 0 && (
              <div className="text-center py-8 text-muted-foreground">
                <Settings className="h-12 w-12 mx-auto mb-4 opacity-50" />
                <p>No applications found matching your filters.</p>
              </div>
            )}
          </div>
        </CardContent>
      </Card>

      {/* App Details Dialog */}
      <Dialog open={!!selectedApp} onOpenChange={() => setSelectedApp(null)}>
        <DialogContent className="sm:max-w-[600px] max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>{selectedApp?.name}</DialogTitle>
            <DialogDescription>
              {selectedApp?.description}
            </DialogDescription>
          </DialogHeader>
          
          {selectedApp && (
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <strong>Domain:</strong> {selectedApp.domain}
                </div>
                <div>
                  <strong>Created:</strong> {new Date(selectedApp.createdAt).toLocaleString()}
                </div>
                <div>
                  <strong>Type:</strong> {selectedApp.isTemplate ? 'Template' : 'App'}
                </div>
                <div>
                  <strong>Auto-Generated:</strong> {selectedApp.parsedMetadata?.autoGenerated ? 'Yes' : 'No'}
                </div>
              </div>
              
              <div>
                <strong>Tags:</strong>
                <div className="flex flex-wrap gap-1 mt-1">
                  {(selectedApp.parsedTags || []).map((tag, index) => (
                    <Badge key={index} variant="outline" className="text-xs">
                      {tag}
                    </Badge>
                  ))}
                </div>
              </div>
              
              <div>
                <strong>Metadata:</strong>
                <div className="bg-muted p-3 rounded text-sm max-h-32 overflow-y-auto mt-1">
                  <pre>{JSON.stringify(selectedApp.parsedMetadata || {}, null, 2)}</pre>
                </div>
              </div>
              
              <div>
                <strong>Original Input:</strong>
                <div className="bg-muted p-3 rounded text-sm max-h-24 overflow-y-auto mt-1">
                  {selectedApp.originalInput}
                </div>
              </div>
            </div>
          )}
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setSelectedApp(null)}>
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete Application</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete "{selectedApp?.name}"? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setDeleteDialogOpen(false)}>
              Cancel
            </Button>
            <Button 
              variant="destructive" 
              onClick={() => selectedApp && handleDeleteApp(selectedApp.id)}
            >
              Delete
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Bulk Delete Dialog */}
      <Dialog open={bulkDeleteDialogOpen} onOpenChange={setBulkDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Bulk Delete Applications</DialogTitle>
            <DialogDescription>
              Choose which applications you want to delete in bulk. This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <Button
              variant="outline"
              className="w-full justify-start"
              onClick={() => handleBulkDelete('old')}
            >
              <Trash2 className="h-4 w-4 mr-2" />
              Delete apps older than 30 days
            </Button>
            
            <Button
              variant="outline"
              className="w-full justify-start"
              onClick={() => handleBulkDelete('autoGenerated')}
            >
              <Trash2 className="h-4 w-4 mr-2" />
              Delete all auto-generated apps
            </Button>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setBulkDeleteDialogOpen(false)}>
              Cancel
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}