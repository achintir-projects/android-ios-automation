import { NextRequest, NextResponse } from 'next/server';
import { savedApps } from '../route';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '50');
    const sortBy = searchParams.get('sortBy') || 'createdAt';
    const sortOrder = searchParams.get('sortOrder') || 'desc';
    const domain = searchParams.get('domain');
    const isTemplate = searchParams.get('template');
    const autoGenerated = searchParams.get('autoGenerated');
    const userId = searchParams.get('userId');
    
    // Get all apps
    let apps = Array.from(savedApps.values());
    
    // Apply filters
    if (domain) {
      apps = apps.filter(app => app.domain === domain);
    }
    
    if (isTemplate !== null) {
      apps = apps.filter(app => app.isTemplate === (isTemplate === 'true'));
    }
    
    if (autoGenerated !== null) {
      const metadata = apps.map(app => {
        try {
          return JSON.parse(app.metadata || '{}');
        } catch {
          return {};
        }
      });
      apps = apps.filter((app, index) => 
        metadata[index].autoGenerated === (autoGenerated === 'true')
      );
    }
    
    if (userId) {
      const metadata = apps.map(app => {
        try {
          return JSON.parse(app.metadata || '{}');
        } catch {
          return {};
        }
      });
      apps = apps.filter((app, index) => 
        metadata[index].userId === userId
      );
    }
    
    // Sort apps
    apps.sort((a, b) => {
      let aValue: any = a[sortBy as keyof typeof a];
      let bValue: any = b[sortBy as keyof typeof b];
      
      // Handle nested metadata sorting
      if (sortBy === 'confidence' || sortBy === 'processingTime' || sortBy === 'requirementCount') {
        try {
          const aMeta = JSON.parse(a.metadata || '{}');
          const bMeta = JSON.parse(b.metadata || '{}');
          aValue = aMeta[sortBy];
          bValue = bMeta[sortBy];
        } catch {
          aValue = 0;
          bValue = 0;
        }
      }
      
      // Convert dates for comparison
      if (sortBy === 'createdAt' || sortBy === 'updatedAt') {
        aValue = new Date(aValue).getTime();
        bValue = new Date(bValue).getTime();
      }
      
      if (sortOrder === 'desc') {
        return bValue > aValue ? 1 : bValue < aValue ? -1 : 0;
      } else {
        return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
      }
    });
    
    // Get statistics
    const stats = {
      totalApps: apps.length,
      templateCount: apps.filter(app => app.isTemplate).length,
      autoGeneratedCount: apps.filter(app => {
        try {
          const meta = JSON.parse(app.metadata || '{}');
          return meta.autoGenerated;
        } catch {
          return false;
        }
      }).length,
      domainDistribution: apps.reduce((acc, app) => {
        acc[app.domain] = (acc[app.domain] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      recentActivity: apps
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 10)
        .map(app => ({
          id: app.id,
          name: app.name,
          createdAt: app.createdAt,
          domain: app.domain,
          isTemplate: app.isTemplate
        }))
    };
    
    // Paginate results
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedApps = apps.slice(startIndex, endIndex);
    
    // Enhance apps with parsed metadata for admin view
    const enhancedApps = paginatedApps.map(app => {
      try {
        const metadata = JSON.parse(app.metadata || '{}');
        return {
          ...app,
          parsedMetadata: metadata,
          parsedRequirements: JSON.parse(app.requirements || '{}'),
          parsedSpecifications: JSON.parse(app.specifications || '{}'),
          parsedTags: JSON.parse(app.tags || '[]')
        };
      } catch {
        return app;
      }
    });
    
    return NextResponse.json({
      success: true,
      data: enhancedApps,
      stats,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(apps.length / limit),
        totalItems: apps.length,
        itemsPerPage: limit
      }
    });
  } catch (error) {
    console.error('Error fetching admin saved apps:', error);
    return NextResponse.json(
      { error: 'Failed to fetch admin saved apps' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const appId = searchParams.get('appId');
    const domain = searchParams.get('domain');
    const olderThan = searchParams.get('olderThan');
    
    let deletedCount = 0;
    let deletedIds: string[] = [];
    
    if (appId) {
      // Delete specific app
      if (savedApps.has(appId)) {
        savedApps.delete(appId);
        deletedCount = 1;
        deletedIds = [appId];
      }
    } else if (domain) {
      // Delete all apps in a domain
      const appsToDelete = Array.from(savedApps.entries()).filter(([_, app]) => app.domain === domain);
      appsToDelete.forEach(([id, _]) => {
        savedApps.delete(id);
        deletedIds.push(id);
      });
      deletedCount = appsToDelete.length;
    } else if (olderThan) {
      // Delete apps older than specified date
      const cutoffDate = new Date(olderThan);
      const appsToDelete = Array.from(savedApps.entries()).filter(([_, app]) => 
        new Date(app.createdAt) < cutoffDate
      );
      appsToDelete.forEach(([id, _]) => {
        savedApps.delete(id);
        deletedIds.push(id);
      });
      deletedCount = appsToDelete.length;
    }
    
    return NextResponse.json({
      success: true,
      deletedCount,
      deletedIds,
      message: `Deleted ${deletedCount} app(s)`
    });
  } catch (error) {
    console.error('Error in admin DELETE operation:', error);
    return NextResponse.json(
      { error: 'Failed to perform admin DELETE operation' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { appId, updates } = body;
    
    if (!appId || !updates) {
      return NextResponse.json(
        { error: 'Missing appId or updates' },
        { status: 400 }
      );
    }
    
    if (!savedApps.has(appId)) {
      return NextResponse.json(
        { error: 'App not found' },
        { status: 404 }
      );
    }
    
    const app = savedApps.get(appId);
    const updatedApp = {
      ...app,
      ...updates,
      updatedAt: new Date().toISOString()
    };
    
    savedApps.set(appId, updatedApp);
    
    return NextResponse.json({
      success: true,
      data: updatedApp,
      message: 'App updated successfully'
    });
  } catch (error) {
    console.error('Error updating app:', error);
    return NextResponse.json(
      { error: 'Failed to update app' },
      { status: 500 }
    );
  }
}